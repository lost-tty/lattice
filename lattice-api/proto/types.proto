syntax = "proto3";

package lattice.daemon.v1;

// ============================================================================
// Core DTO Types - Single source of truth for all Lattice types
// ============================================================================

message Empty {}

// ============================================================================
// Node Types
// ============================================================================

message NodeStatus {
  bytes public_key = 1;
  string display_name = 2;
  string data_path = 3;
  uint32 mesh_count = 4;
}

message SetNameRequest {
  string name = 1;
}

// ============================================================================
// Event Types
// ============================================================================

message NodeEvent {
  reserved 1; // mesh_ready
  oneof node_event {
    StoreReadyEvent store_ready = 2;
    JoinFailedEvent join_failed = 3;
    SyncResultEvent sync_result = 4;
  }
}

message StoreReadyEvent {
  bytes root_id = 1;
  bytes store_id = 2;
}

message JoinFailedEvent {
  bytes root_id = 1;
  string reason = 2;
}

message SyncResultEvent {
  bytes store_id = 1;
  uint32 peers_synced = 2;
  uint64 entries_sent = 3;
  uint64 entries_received = 4;
}

// ============================================================================
// Store Types
// ============================================================================

message ListStoreRequest {
  optional bytes parent_id = 1;
}

message JoinRequest {
  string token = 1;
}

message JoinResponse {
  bytes store_id = 1;
}

message InviteToken {
  string token = 1;
}

message PeerInfo {
  bytes public_key = 1;
  string status = 2;
  bool online = 3;
  string name = 4;
  uint64 last_seen_ms = 5;
  uint64 added_at = 6;
}

message PeerList {
  repeated PeerInfo peers = 1;
}

message RevokePeerRequest {
  bytes store_id = 1;
  bytes peer_key = 2;
}

// ============================================================================
// Store Types
// ============================================================================

message StoreId {
  bytes id = 1;
}

message CreateStoreRequest {
  optional bytes parent_id = 1;
  string name = 2;
  string store_type = 3;
}

message SetStoreNameRequest {
  bytes store_id = 1;
  string name = 2;
}

message DeleteStoreRequest {
  bytes store_id = 1;
  bytes child_id = 2;
}

message StoreNameResponse {
  optional string name = 1;
}

message PeerStrategyResponse {
  optional string strategy = 1;
}

// Store reference
message StoreRef {
  bytes id = 1;
  string store_type = 2;
  string name = 3;
  bool archived = 4;
}

// Store metadata
message StoreMeta {
  bytes id = 1;
  string store_type = 2;
  uint64 schema_version = 4;
}

// List of store references
message StoreList {
  repeated StoreRef stores = 1;
}

// Runtime statistics
message StoreDetails {
  uint32 author_count = 1;
  uint64 intention_count = 2;
  uint64 witness_count = 3;
}

message SyncResult {
  uint32 peers_synced = 1;
  uint64 entries_sent = 2;
  uint64 entries_received = 3;
}

message DebugInfo {
  repeated AuthorState authors = 1;
}

message WitnessLogRequest {
  bytes store_id = 1;
}

// Causal dependency condition — mirrors kernel's Condition enum.
message Condition {
  oneof condition {
    CausalDeps v1 = 1;  // Explicit causal dependencies (AND logic)
  }
}

message CausalDeps {
  repeated bytes hashes = 1;  // Sorted list of prerequisite intention hashes
}

message HLC {
  uint64 wall_time = 1;  // Milliseconds since Unix epoch
  uint32 counter = 2;    // Logical counter for same-ms ordering
}

// Signed intention — structured API representation.
// (Internal storage uses Borsh for deterministic hashing; this is the user-facing view.)
message SignedIntention {
  bytes hash = 1;               // blake3 content hash (32 bytes)
  bytes author = 2;             // Ed25519 public key (32 bytes)
  bytes signature = 3;          // Ed25519 signature (64 bytes)
  HLC timestamp = 4;            // Hybrid logical clock
  bytes store_id = 5;           // Target store UUID (16 bytes)
  bytes store_prev = 6;         // Previous intention hash in author's chain
  Condition condition = 7;      // Causal dependency condition
  bytes ops = 8;                // Opaque operation payload
}

// Transport wrapper: weaver.WitnessRecord + sequence number.
// content/signature fields mirror weaver.proto WitnessRecord exactly.
message WitnessLogEntry {
  uint64 seq = 1;               // Witness sequence (apply order)
  bytes hash = 4;               // blake3(content) — the chain hash
  bytes content = 2;            // protobuf-encoded WitnessContent
  bytes signature = 3;          // Ed25519 signature over blake3(content)
}

// Structured s-expression for operation summaries.
message SExpr {
  oneof value {
    string symbol = 1;  // Unquoted symbol/keyword: put, child-add, :active
    string str = 2;     // Quoted string value
    bytes raw = 3;      // Binary data (rendered as hex)
    uint64 num = 4;     // Numeric value
    SExprList list = 5; // Nested list: (put "key" "value")
  }
}

message SExprList {
  repeated SExpr items = 1;
}

message WitnessLogResponse {
  repeated WitnessLogEntry entries = 1;
}

message FloatingIntentionsResponse {
  repeated SignedIntention intentions = 1;
}

message GetIntentionRequest {
  bytes store_id = 1;
  bytes hash_prefix = 2;
}

message GetIntentionResponse {
  SignedIntention intention = 1;
  repeated SExpr ops = 2;
}

message AuthorStateRequest {
  bytes store_id = 1;
  bytes author_key = 2;
}

message AuthorState {
  bytes public_key = 1;
  uint64 seq = 2;
  bytes hash = 3;
}

message AuthorStateResponse {
  repeated AuthorState authors = 1;
}

message CleanupResult {
  uint32 orphans_removed = 1;
}

message SystemEntry {
  string key = 1;
  bytes value = 2;
}

message SystemListResponse {
  repeated SystemEntry entries = 1;
}

// ============================================================================
// Dynamic Store Types
// ============================================================================

message ExecRequest {
  bytes store_id = 1;
  string method = 2;
  bytes payload = 3;
}

enum ErrorCode {
  UNKNOWN = 0;
  STORE_NOT_FOUND = 1;
  METHOD_NOT_FOUND = 2;
  INVALID_ARGUMENT = 3;
  EXECUTION_FAILED = 4;
}

message ExecResponse {
  bytes result = 1;
  string error = 2;
  ErrorCode error_code = 3;
}

message DescriptorResponse {
  bytes file_descriptor_set = 1;
  string service_name = 2;
}

message MethodInfo {
  string name = 1;
  string description = 2;
}

message MethodList {
  repeated MethodInfo methods = 1;
}

// ============================================================================
// Stream Subscription Types
// ============================================================================

// Descriptor for a subscribable event stream
message StreamDescriptor {
  string name = 1;
  string description = 2;
  string param_schema = 3;   // Proto message name for params (if any)
  string event_schema = 4;   // Proto message name for events
}

message StreamList {
  repeated StreamDescriptor streams = 1;
}

// Subscribe to a store stream
message SubscribeRequest {
  bytes store_id = 1;
  string stream_name = 2;
  bytes params = 3;  // Encoded stream-specific params
}

// Event from a store stream
message StoreEvent {
  bytes payload = 1;  // Encoded stream event
}
