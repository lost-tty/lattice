syntax = "proto3";

package lattice.network;

import "storage.proto";
import "weaver.proto";

// 1. Join Protocol
message JoinRequest {
  bytes node_pubkey = 1;  // Joining node's public key (32 bytes)
  bytes store_id = 2;     // Store UUID to join (16 bytes, MANDATORY)
  bytes invite_secret = 3;  // Secret from invite token (MANDATORY)
}

message InviteToken {
    bytes store_id = 1;
    bytes secret = 2;
    bytes inviter_pubkey = 3;
}

message JoinResponse {
  bytes inviter_pubkey = 1;  // Inviter's public key for verification
  bytes store_id = 2;       // Root store UUID (16 bytes) for new node to create
}

// 2. Peer Message Wrapper (unicast RPC)
message PeerMessage {
  oneof message {
    JoinRequest join_request = 1;
    JoinResponse join_response = 2;
    FetchIntentions fetch_intentions = 3;
    IntentionResponse intention_response = 4;
    ReconcilePayload reconcile = 5;
    FetchChain fetch_chain = 6;
    BootstrapRequest bootstrap_request = 7;
    BootstrapResponse bootstrap_response = 8;
  }
}

// 7. Bootstrap (Clone) Protocol
message BootstrapRequest {
  bytes store_id = 1;      // Store UUID
  bytes start_hash = 2;    // Hash of the last known witness entry (or all-zeros for start)
  uint32 limit = 3;        // Max items to fetch
}

message BootstrapResponse {
  bytes store_id = 1;
  repeated lattice.weaver.WitnessRecord witness_records = 2;
  repeated lattice.weaver.SignedIntention intentions = 3;
  bool done = 4;
}

// 4. Fetch Intentions â€” used to retrieve missing data
message FetchIntentions {
  bytes store_id = 1;
  repeated bytes hashes = 2;   // List of content hashes to fetch
}

message FetchChain {
  bytes store_id = 1;
  bytes target_hash = 2; // The tip of the gap (hash we want)
  bytes since_hash = 3;  // The base of the gap (what we last had from this author).
                         // Empty if we have nothing (new author).
}

message IntentionResponse {
  bytes store_id = 1;
  bool done = 2;               // True if this is the last batch
  repeated lattice.weaver.SignedIntention intentions = 3;
}

// 5. Gossip Protocol - propagates new items eagerly
message GossipMessage {
  bytes store_id = 1;
  oneof content {
    lattice.weaver.SignedIntention intention = 2;
  }
}

// 6. Reconciliation Protocol (Negentropy)
message ReconcilePayload {
  bytes store_id = 1;
  ReconcileMessage message = 2;
}

message ReconcileMessage {
  oneof content {
    RangeFingerprint range_fingerprint = 1;
    RangeItemsRequest range_items_request = 2;
    RangeItemsReply range_items_reply = 3;
    bool done = 4;
  }
}

message RangeFingerprint {
  bytes start = 1;
  bytes end = 2;
  bytes fingerprint = 3;
  uint64 count = 4;
}

message RangeItemsRequest {
  bytes start = 1;
  bytes end = 2;
  repeated bytes hashes = 3;
}

message RangeItemsReply {
  bytes start = 1;
  bytes end = 2;
  repeated bytes hashes = 3;
}
