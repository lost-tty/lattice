syntax = "proto3";

package lattice.storage;

// Hybrid Logical Clock - used throughout
message HLC {
  uint64 wall_time = 1;  // Unix timestamp (ms)
  uint32 counter = 2;    // Logical counter for same-ms ordering
}

// 5. Per-author state (DB and wire)
message ChainTip {
  uint64 seq = 1;   // Highest sequence number from this author
  bytes hash = 2;   // Hash of last entry (tip of author's chain)
  HLC hlc = 4;      // Highest HLC seen from this author
}

// 8. Stored peer sync info (state.db)
message PeerSyncInfo {
  SyncState sync_state = 1;  // Peer's last known sync state
  uint64 updated_at = 2;     // Unix timestamp (seconds) when received
}

// 9. Sync state (shared between storage and network)
message SyncState {
  repeated SyncAuthor authors = 1;  // Per-author sync state
  HLC sender_hlc = 2;               // Sender's current clock
  HLC common_hlc = 3;               // Min of max HLCs across all authors
}

message SyncAuthor {
  bytes author_id = 1;    // Ed25519 public key (32 bytes)
  ChainTip state = 2;  // The author's sync state
}

// 10. Root store metadata (stored in meta.db)
message RootStoreRecord {
  uint64 joined_at = 1;    // Unix timestamp (ms) when joined/created
}

// 11. Store metadata (stored in meta.db)
message StoreRecord {
  bytes parent_id = 1;     // UUID of the parent store (if any)
  uint64 created_at = 2;   // Unix timestamp (ms) when created
}

// --- System Operations (M10A) ---

message UniversalOp {
    oneof op {
        bytes app_data = 10;
        SystemOp system = 11;
    }
}

message SystemOp {
    oneof kind {
        HierarchyOp hierarchy = 1;
        PeerOp peer = 2;
        PeerStrategyOp strategy = 3;
        StoreOp store = 4;
        InviteOp invite = 5;
        SystemBatch batch = 6;
    }
}

// Batch of system operations â€” applied atomically in one intention.
message SystemBatch {
    repeated SystemOp ops = 1;
}

message StoreOp {
    oneof op {
        SetStoreName set_name = 1;
    }
}

message SetStoreName {
    string name = 1;
}

// Hierarchy Management
message HierarchyOp {
    oneof op {
        ChildAdd add_child = 1;
        ChildRemove remove_child = 2;
        ChildSetStatus set_status = 3;
    }
}

message ChildAdd {
    bytes target_id = 1;
    string alias = 2;
    string store_type = 3;
}

message ChildRemove {
    bytes target_id = 1;
}

message ChildSetStatus {
    bytes target_id = 1;
    ChildStatus status = 2;
}

enum ChildStatus {
    CS_UNKNOWN = 0;
    CS_ACTIVE = 1;
    CS_ARCHIVED = 2;
}

// Peer Management
message PeerOp {
    bytes pubkey = 1;
    oneof op {
        SetPeerStatus set_status = 3;
        SetPeerAddedAt set_added_at = 4;
        SetPeerAddedBy set_added_by = 5;
        SetPeerName set_name = 6;
    }
}

message SetPeerStatus {
    PeerStatus status = 1;
}

message SetPeerAddedAt {
    uint64 timestamp = 1;
}

message SetPeerAddedBy {
    bytes adder_pubkey = 1;
}

message SetPeerName {
    string name = 1;
}

enum PeerStatus {
    UNKNOWN = 0;
    INVITED = 1;
    ACTIVE = 2;
    DORMANT = 3;
    REVOKED = 4;
}

// Peer Strategy Management
message PeerStrategyOp {
    oneof op {
        SetPeerStrategy set = 1;
    }
}

message SetPeerStrategy {
    PeerStrategy strategy = 1;
}

message PeerStrategy {
    oneof type {
         bool independent = 1;
         bool inherited = 2;
         bytes snapshot = 3; // UUID bytes
    }
}

// Invite Management
message InviteOp {
    bytes token_hash = 1;
    oneof op {
        SetInviteStatus set_status = 2;
        SetInviteInvitedBy set_invited_by = 3;
        SetInviteClaimedBy set_claimed_by = 4;
    }
}

message SetInviteStatus {
    InviteStatus status = 1;
}

message SetInviteInvitedBy {
    bytes inviter_pubkey = 1;
}

message SetInviteClaimedBy {
    bytes claimer_pubkey = 1;
}

enum InviteStatus {
    INVITE_STATUS_UNKNOWN = 0;
    INVITE_STATUS_VALID = 1;
    INVITE_STATUS_REVOKED = 2;
    INVITE_STATUS_CLAIMED = 3;
}

