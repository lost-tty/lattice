syntax = "proto3";

package lattice;

// 1. The Wrapper (What flies over the wire)
message SignedEntry {
  // The serialized bytes of the 'Entry' message.
  // We keep this as raw bytes so the signature verification is stable.
  bytes entry_bytes = 1;
  
  // Ed25519 Signature of 'entry_bytes'
  bytes signature = 2;
  
  // Public Key of the author (32 bytes)
  bytes author_id = 3;
}

// 2. The Log Entry (The Atomic Unit)
message Entry {
  // Versioning allows us to change the format radically later if needed
  uint32 version = 1;

  // Store this entry belongs to (16-byte UUID)
  bytes store_id = 6;

  // Ordering Metadata
  bytes prev_hash = 2;   // Link to previous sigchain entry (32 bytes)
  uint64 seq = 3;        // Monotonic sequence number
  HLC timestamp = 4;     // Hybrid Logical Clock

  // DAG ancestry: hashes of entries this supersedes (separate from sigchain)
  repeated bytes parent_hashes = 7;

  // The Batch of Operations
  repeated Operation ops = 5;
}

// HeadInfo: a tip/head in the DAG for a key
message HeadInfo {
  bytes value = 1;       // The value at this head
  HLC hlc = 2;           // HLC for ordering
  bytes author = 3;      // Author's public key (32 bytes)
  bytes hash = 4;        // Hash of the SignedEntry that created this head
  bool tombstone = 5;    // True if this head represents a delete
}

// HeadList: wrapper for storing multiple heads per key in state.db
message HeadList {
  repeated HeadInfo heads = 1;
}

// AuthorState: per-author sync state (used for both DB and wire)
message AuthorState {
  uint64 seq = 1;              // Highest sequence number from this author
  bytes hash = 2;              // Hash of last entry (tip of sigchain)
  HLC hlc = 4;                 // Highest HLC seen from this author
}

// Hybrid Logical Clock
message HLC {
  uint64 wall_time = 1;  // Unix timestamp (ms)
  uint32 counter = 2;    // Logical counter for same-ms ordering
}

// 3. The Operation (The Change)
message Operation {
  // "oneof" is how Protobuf handles Rust Enums
  oneof op_type {
    PutOp put = 1;
    DeleteOp delete = 2;
    // Future: MergeOp merge = 3;
  }
}

message PutOp {
  bytes key = 1;
  bytes value = 2;
}

message DeleteOp {
  bytes key = 1;
}

// 4. The Sync Handshake (Vector Clocks)
message SyncState {
  repeated SyncAuthor authors = 1;  // Per-author sync state
  HLC sender_hlc = 2;               // Sender's current clock
  HLC common_hlc = 3;               // Min of max HLCs across all authors
}

// Per-author sync info for wire format (includes author_id)
message SyncAuthor {
  bytes author_id = 1;         // Ed25519 public key (32 bytes)
  AuthorState state = 2;       // The author's sync state
}

// 5. Log File Record (wrapper for storage)
message LogRecord {
  bytes hash = 1;         // BLAKE3 hash of entry_bytes (32 bytes)
  bytes entry_bytes = 2;  // Serialized SignedEntry
}

// 6. Join Protocol Messages (new node joining existing mesh)
message JoinRequest {
  bytes node_pubkey = 1;  // Joining node's public key (32 bytes)
}

message JoinResponse {
  bytes store_uuid = 1;   // Root store UUID (16 bytes) for new node to create
  bytes inviter_pubkey = 2;  // Inviter's public key for verification
}

// 7. Peer Message Wrapper (for proper message type discrimination)
message PeerMessage {
  oneof message {
    JoinRequest join_request = 1;
    JoinResponse join_response = 2;
    StatusRequest status_request = 3;
    StatusResponse status_response = 4;
    FetchRequest fetch_request = 5;
    FetchResponse fetch_response = 6;
  }
}

// 9. Orphan Entry (for orphan buffer storage)
message OrphanedEntry {
  uint64 seq = 1;            // Sequence number of the orphaned entry
  SignedEntry entry = 2;     // The orphaned entry itself
  uint64 received_at = 3;    // Unix timestamp (seconds) when orphan was received
}

// 10. Gossip Message Wrapper (supports piggybacking - both fields in one message)
message GossipMessage {
  optional SignedEntry entry = 1;       // Entry broadcast (if any)
  optional SyncState sender_state = 2;  // Sender's sync state (piggybacked)
}

// 11. Sync State Announcement (gossip broadcast)
message SyncStateAnnounce {
  bytes store_id = 1;        // Store UUID (16 bytes)
  SyncState sync_state = 2;  // Sender's current sync state
}

// 12. Stored peer sync info (for state.db)
message PeerSyncInfo {
  SyncState sync_state = 1;  // Peer's last known sync state
  uint64 updated_at = 2;     // Unix timestamp (seconds) when received
}

// 13. Fetch Protocol Messages (targeted entry fetching)
message AuthorRange {
  bytes author_id = 1;       // Author public key (32 bytes)
  uint64 from_seq = 2;       // Inclusive start sequence
  uint64 to_seq = 3;         // Inclusive end sequence (0 = to latest)
}

message FetchRequest {
  bytes store_id = 1;        // Store UUID (16 bytes)
  repeated AuthorRange ranges = 2;  // Ranges to fetch
}

message FetchResponse {
  bytes store_id = 1;        // Store UUID (16 bytes)
  uint32 status = 2;         // HTTP-like: 200=OK, 206=Partial, 401=Unauthorized, 404=NotFound
  bool done = 3;             // true = last chunk (stream complete)
  repeated SignedEntry entries = 4;  // Chunk of entries (may be empty on final message)
}

// Request sync status from peers
message StatusRequest {
  bytes store_id = 1;        // Store UUID to get status for (16 bytes)
  SyncState sync_state = 2;  // Sender's current sync state
}

// Response with sync status
message StatusResponse {
  bytes store_id = 1;        // Store UUID (16 bytes)
  SyncState sync_state = 2;  // Responder's current sync state
}
